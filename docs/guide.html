<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <title>Mad Dog Mock — Documentação</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Helvetica, Arial, sans-serif; line-height: 1.6; margin: 2rem; max-width: 980px; }
    pre { background: #0b1020; color: #e6edf3; padding: 1rem; overflow: auto; border-radius: 8px; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    h1, h2, h3 { line-height: 1.25; }
    h1 { margin-top: 0; }
    hr { border: 0; border-top: 1px solid #ddd; margin: 2rem 0; }
    .muted { color: #666; }
    .pill { display:inline-block; padding: .15rem .5rem; border:1px solid #999; border-radius:999px; font-size:.85rem; }
  </style>
</head>
<body>
  <h1>Mad Dog Mock — Documentação Oficial</h1>
  <p class="muted"><strong>Versão:</strong> 1.0 • <strong>Última atualização:</strong> 27/08/2025</p>
  <p><strong>Descrição:</strong> Mad Dog Mock é uma API web para criação de <em>mocks HTTP dinâmicos</em>, organizados por <em>cenários</em> com basepath próprio, Swagger por cenário, CRUD completo, variações de retorno por condição (headers, query, path, JSONPath em body, e claims de JWT OpenID), e armazenamento em memória ou externo (cache NoSQL/in-memory).</p>
  <hr/>

  <h2>1. Visão Geral</h2>
  <p>O <strong>Mad Dog Mock</strong> permite criar <strong>endpoints HTTP</strong> sem codar rotas manualmente. Você cadastra <strong>cenários</strong> (cada um com um <code>basepath</code> único) e <strong>mocks</strong> dentro deles (método + URI), define <strong>variantes de retorno</strong> com <strong>condições</strong>, e obtém um <strong>Swagger</strong> exclusivo por cenário para testar.</p>
  <ul>
    <li>Paths dinâmicos por cenário (<code>/{basepath}/...</code>).</li>
    <li>CRUD de cenários e mocks (listar, consultar, incluir, alterar, excluir).</li>
    <li>Swagger geral (CRUD) e Swagger por cenário.</li>
    <li>Condições: header, query, path params, JSONPath (body), JWT OpenID.</li>
    <li>Armazenamento: InMemory, Redis ou Mongo.</li>
  </ul>

  <h2>2. Conceitos</h2>
  <h3>Cenário</h3>
  <p>Agrupador de mocks com um <strong>basepath</strong> único (ex.: <code>bank/v1</code>). O <strong>basepath é o identificador</strong> do cenário. Cada cenário tem <strong>Swagger próprio</strong>.</p>
  <h3>Mock</h3>
  <p>Um endpoint HTTP caracterizado por: método, uri, parâmetros, contentType, tags, nome/descrição e <strong>variantes</strong>.</p>
  <h3>Variante</h3>
  <p>Uma possível resposta com: status, headers, contentType, payload e uma <strong>condição</strong> (opcional). Avaliação em ordem; primeira verdadeira vence. Fallback: a variante sem condição.</p>

  <h2>3. Pré-requisitos</h2>
  <h3>Para criar um cenário</h3>
  <ul>
    <li><code>basepath</code> único (ex.: <code>bank/v1</code>)</li>
    <li><code>name</code> e <code>description</code> (opcionais)</li>
    <li>Config JWT (opcional): issuer URL (https), origem (header/cookie), e nome do header ou cookie (com suporte a <span class="pill">Bearer</span>).</li>
  </ul>
  <h3>Para criar um mock</h3>
  <ul>
    <li><code>scenarioBasepath</code>, <code>method</code>, <code>uri</code></li>
    <li>Metadados opcionais: <code>name</code>, <code>description</code>, <code>tags</code>, <code>request</code></li>
    <li>Uma ou mais <code>responses</code> (variantes)</li>
    <li>Regra anti-duplicidade: POST recusa mock igual; use PUT.</li>
  </ul>

  <h2>4. Endpoints de Administração (CRUD)</h2>
  <p>Swagger geral: <code>/docs</code></p>

  <h3>4.1. Cenários</h3>
  <ul>
    <li><strong>GET</strong> <code>/api/scenarios</code> — lista com <code>swaggerUrl</code></li>
    <li><strong>POST</strong> <code>/api/scenarios</code> — cria cenário</li>
    <li><strong>GET</strong> <code>/api/scenarios/{basepath}</code> — consulta</li>
    <li><strong>PUT</strong> <code>/api/scenarios/{basepath}</code> — atualiza</li>
    <li><strong>DELETE</strong> <code>/api/scenarios/{basepath}</code> — exclui em cascata</li>
  </ul>

  <h3>4.2. Mocks</h3>
  <ul>
    <li><strong>GET</strong> <code>/api/mocks?scenario={basepath}</code> — lista</li>
    <li><strong>POST</strong> <code>/api/mocks</code> — cria (falha se duplicado)</li>
    <li><strong>GET</strong> <code>/api/mocks/{mockId}</code> — consulta</li>
    <li><strong>PUT</strong> <code>/api/mocks/{mockId}</code> — altera</li>
    <li><strong>DELETE</strong> <code>/api/mocks/{mockId}</code> — remove</li>
  </ul>

  <h2>5. DSL de Condições & Variantes</h2>
  <p>Operadores: <code>==</code>, <code>!=</code>, <code>in</code>, <code>contains</code>, <code>startswith</code>, <code>endswith</code>, <code>~</code> (regex), parênteses, <code>and</code>, <code>or</code>, <code>not</code>.</p>
  <p>Contexto: <code>header.*</code>, <code>query.*</code>, <code>path.*</code>, <code>jsonpath('...')</code>, <code>jwt.*</code>, <code>jwt.header.*</code>, <code>jwt.realm_access.roles</code>, <code>jwt.resource_access</code>.</p>

  <h2>6. Swagger por Cenário</h2>
  <ul>
    <li>UI: <code>/scenarios/{basepath}/docs</code></li>
    <li>OpenAPI: <code>/scenarios/{basepath}/openapi.json</code></li>
  </ul>

  <h2>7. JWT (OpenID)</h2>
  <ul>
    <li>Validação quando o token está presente no local configurado.</li>
    <li>Erros: ausente (400), issuer inacessível (502/503), inválido (401).</li>
    <li>Claims disponíveis em <code>jwt.*</code> nas condições.</li>
  </ul>

  <h2>8. Exemplos (cURL)</h2>
  <h3>8.1. Criar cenário</h3>
  <pre><code>curl -X POST http://localhost:8080/api/scenarios \
  -H "Content-Type: application/json" \
  -d '{"basepath":"bank/v1","name":"Banking","description":"APIs bancárias",
       "jwt":{"issuerUrl":"https://issuer.example.com/realms/demo","location":"header","headerName":"Authorization","bearer":true}}'</code></pre>

  <h3>8.2. Criar mocks (vários métodos)</h3>
  <pre><code>curl -X POST http://localhost:8080/api/mocks \
  -H "Content-Type: application/json" \
  -d '{"scenarioBasepath":"bank/v1","method":"GET","uri":"/accounts/{id}","responses":[{"status":200,"contentType":"application/json","payload":{"id":"{{path.id}}","ok":true}}]}'</code></pre>

  <h3>8.3. Variações por condição</h3>
  <pre><code>"responses":[
  {"status":200,"condition":"header.X-Env == 'prod'","payload":{"env":"prod"}},
  {"status":200,"condition":"query.debug == 'true'","payload":{"debug":true}},
  {"status":200,"condition":"jwt.realm_access.roles contains 'admin'","payload":{"role":"admin"}},
  {"status":200,"payload":{"ok":true}}
]</code></pre>

  <h3>8.4. Retorno com dados "dinâmicos"</h3>
  <pre><code>{"status":200,"payload":{"id":"{{path.id}}","user":"{{jsonpath('$.user.name')}}","who":"{{jwt.preferred_username}}","ts":"{{now}}","reqId":"{{uuid}}"}}</code></pre>

  <h2>9. Erros Padrão</h2>
  <pre><code>{"error":"jwt_missing","message":"Token JWT não encontrado no header/cookie configurado"}</code></pre>

  <h2>10. Armazenamento & Cache</h2>
  <p>InMemory por padrão; Redis/Mongo via variáveis de ambiente.</p>

  <h2>11. Deploy (resumo)</h2>
  <p>Docker Compose: <code>docker compose up --build</code>. OpenShift: use imagem Docker e exponha rota HTTP.</p>

  <hr/>
  <p class="muted">© 2025 Mad Dog Mock</p>
</body>
</html>
